درست است. این ترجمه ای که از سوال ارائه دادید:

---

## چالش: محدوده اعداد با استفاده از بازگشت

## دستورالعمل‌ها

یک تابع به نام `numberRange` بنویسید که یک `startNum` و یک `endNum` را دریافت کرده و یک آرایه از اعداد از `startNum` تا `endNum` را، شامل هر دو عدد، برمی‌گرداند. اطمینان حاصل کنید که در راه‌حل خود از بازگشت استفاده کنید.

### امضاء تابع

```js
/**
 * یک آرایه از اعداد از startNum تا endNum را، شامل هر دو عدد، برمی‌گرداند.
 * @param {number} startNum - عدد شروع.
 * @param {number} endNum - عدد پایانی.
 * @returns {number[]} - یک آرایه از اعداد.
 */
function numberRange(startNum: number, endNum: number): number[];
```

### مثال‌ها

```js
numberRange(1, 5); // باید [1, 2, 3, 4, 5] برگرداند
numberRange(3, 10); // باید [3, 4, 5, 6, 7, 8, 9, 10] برگرداند
numberRange(7, 7); // باید [7] برگرداند (فقط یک عدد)
```

### راهنمایی‌ها

- می‌توانید آرایه را با ابتدا فراخوانی `numberRange` برای محدوده کوچکتر ایجاد کنید و سپس `endNum` را به آرایه اضافه کنید.

## راه‌حل‌ها

<details>
  <summary>برای دیدن راه‌حل کلیک کنید</summary>

```js
function numberRange(startNum, endNum) {
  if (startNum === endNum) {
    return [startNum];
  }

  const numbers = numberRange(startNum, endNum - 1);
  numbers.push(endNum);
  return numbers;
}
```

### توضیحات

- ابتدا مورد پایه خود را اضافه می‌کنیم و بررسی می‌کنیم که آیا `startNum` برابر با `endNum` است یا خیر. اگر بود، `startNum` را در یک آرایه برمی‌گردانیم.
- برای مورد بازگشتی، متغیر `numbers` را به عملکرد با `startNum` و یک واحد کمتر از `endNum` تنظیم می‌کنیم.
- سپس `endNum` را به آرایه `numbers` اضافه می‌کنیم و آن را برمی‌گردانیم.

این خلاصه اصل موضوع است، اما بیایید قدم به قدم برای `numberRange(1, 5)` برویم.

گام 1: از آنجا که `startNum(1)` برابر با `endNum(5)` نیست، به بلوک بازگشتی می‌رویم.

گام 2: فراخوانی بازگشتی به `numberRange(1، 4)` را ایجاد می‌کنیم که به `numberRange(1، 3)` و ... و ... و ...

گام 3: مورد پایه زمانی است که `startNum(1)` برابر با `endNum(1)` می‌شود. در این نقطه، تابع یک آرایه شامل فقط عدد 1 را برمی‌گرداند.

گام 4: بازگشت شروع می‌شود. نتیجه `numberRange(1، 2)` حالا یک آرایه `[1، 2]` است. سپس، نتیجه `numberRange(1، 3)` `[1، 2، 3]`، و ... و ... و ... تا آخرین نتیجه `numberRange(1، 5)` به `[1، 2، 3، 4، 5]` می‌رسد.

تابع با همان فرآیند بازگشتی ادامه می‌دهد تا آرایه اعداد را ایجاد کند، از مورد پایه شروع کرده و تعداد عدد به تعدادی که تماس‌های بازگشتی را باز می‌گرداند اضافه می‌کند.

</details>

### موارد آزمون

```js
test('Calculating the range of numbers', () => {
  expect(numberRange(1, 5)).toEqual([1, 2, 3, 4, 5]);
  expect(numberRange(3, 10)).toEqual([3, 4, 5, 6, 7, 8, 9, 10]);
  expect(numberRange(7, 7)).toEqual([7]);
});
```

---