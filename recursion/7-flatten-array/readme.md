درست است، این ترجمه‌ی سوال به فارسی:

---

## چالش: تغییر آرایه به فلت

## دستورالعمل‌ها

تابعی به نام `flattenArray` بنویسید که یک آرایه شامل زیرآرایه‌های درونی اعداد صحیح را دریافت کرده و یک آرایه جدید با تمام اعداد از زیرآرایه‌های درونی را به یک سطح فلت شده برگرداند.

### امضاء تابع

```js
/**
 * یک آرایه فلت شده را برمی‌گرداند.
 * @param {number[]} arr - آرایه‌ای که شامل زیرآرایه‌های درونی است.
 * @returns {number[]} - آرایه فلت شده.
 */
function flattenArray(arr: number[]): number[];
```

### مثال‌ها

```js
flattenArray([1, [2, 3], [4, 5, [6]]]); // باید [1, 2, 3, 4, 5, 6] برگرداند
flattenArray([
  [1, 2],
  [3, [4, 5]],
  [6, [7]],
]); // باید [1, 2, 3, 4, 5, 6, 7] برگرداند
flattenArray([1, [2, [3, [4, [5]]]]]); // باید [1, 2, 3, 4, 5] برگرداند
```

### محدودیت‌ها

- آرایه ورودی می‌تواند شامل زیرآرایه‌های درونی با هر عمقی باشد
- آرایه ورودی می‌تواند هر تعداد زیرآرایه درونی داشته باشد

### راهنمایی‌ها

- می‌توانید از بازگشت برای عبور از زیرآرایه‌های درونی و تغییر آن‌ها به فلت استفاده کنید.
- اگر عنصر فعلی یک آرایه باشد، می‌توانید به صورت بازگشتی تابع `flattenArray` را روی آن عنصر فراخوانی کنید تا آن را فلت کنید.

## راه‌حل‌ها

<details>
  <summary>برای دیدن راه‌حل کلیک کنید</summary>

```js
function flattenArray(arr) {
  let result = [];

  for (const item of arr) {
    if (Array.isArray(item)) {
      result = result.concat(flattenArray(item));
    } else {
      result.push(item);
    }
  }

  return result;
}
```

### توضیحات

- یک متغیر `result` برای ذخیره آرایه فلت شده ایجاد کنید.
- با استفاده از حلقه `for...of` از آرایه ورودی عبور کنید.
- اگر عنصر فعلی یک آرایه باشد، به صورت بازگشتی تابع `flattenArray` را روی آن عنصر فراخوانی کنید تا آن را فلت کنید و سپس نتیجه را به آرایه `result` اضافه کنید.
- اگر عنصر فعلی یک آرایه نباشد، آن را به آرایه `result` اضافه کنید.
- آرایه `result` را برگردانید.

مورد پایه به صورت ضمنی در داخل ساختار حلقه استفاده می‌شود. در حالی که حلقه از هر عنصر آرایه ورودی `arr` عبور می‌کند، بازگشت به نقطه‌ای که دیگر عناصر برای پردازش باقی نمانده است، بالاخره انجام می‌شود.

وقتی آرایه ورودی `arr` خالی است، حلقه اجرا نمی‌شود و تابع به طور مستقیم آرایه نتیجه خالی را برمی‌گرداند.

</details>

### موارد آزمون

```js
test('Flatten Nested Arrays', () => {
  expect(flattenArray([1, [2, 3], [4, 5, [6]]])).toEqual([1, 2, 3, 4, 5, 6]);
  expect(
    flattenArray([
      [1, 2],
      [3, [4, 5]],
      [6, [7]],
    ])
  ).toEqual([1, 2, 3, 4, 5, 6, 7]);
  expect(flattenArray([1, [2, [3, [4, [5]]]]])).toEqual([1, 2, 3, 4, 5]);
});
```

--- 